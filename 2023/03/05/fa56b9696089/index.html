<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>GMP原理 | 爱开源GoGo</title><meta name="author" content="JimmyDing"><meta name="copyright" content="JimmyDing"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[TOC] 2.4 GMP源码剖析 2.4.1 协程G结构体 1234567891011121314151617181920212223242526&#x2F;&#x2F; src&#x2F;runtime&#x2F;runtime2.gotype g struct &#123;    stack       stack   &#x2F;&#x2F; 保存当前协程栈的上界和下界    &#x2F;&#x2F; stackguard0 是对比 Go 栈增长的 prologue">
<meta property="og:type" content="article">
<meta property="og:title" content="GMP原理">
<meta property="og:url" content="https://mylofty.github.io/2023/03/05/fa56b9696089/index.html">
<meta property="og:site_name" content="爱开源GoGo">
<meta property="og:description" content="[TOC] 2.4 GMP源码剖析 2.4.1 协程G结构体 1234567891011121314151617181920212223242526&#x2F;&#x2F; src&#x2F;runtime&#x2F;runtime2.gotype g struct &#123;    stack       stack   &#x2F;&#x2F; 保存当前协程栈的上界和下界    &#x2F;&#x2F; stackguard0 是对比 Go 栈增长的 prologue">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2023-03-04T16:00:00.000Z">
<meta property="article:modified_time" content="2025-05-09T07:04:26.773Z">
<meta property="article:author" content="JimmyDing">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/images/notebook.png"><link rel="canonical" href="https://mylofty.github.io/2023/03/05/fa56b9696089/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'GMP原理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-05-09 15:04:26'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/notebook.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="爱开源GoGo"><span class="site-name">爱开源GoGo</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 图库</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">GMP原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-04T16:00:00.000Z" title="发表于 2023-03-05 00:00:00">2023-03-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-09T07:04:26.773Z" title="更新于 2025-05-09 15:04:26">2025-05-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Go/">Go</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="GMP原理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>[TOC]</p>
<h1>2.4 GMP源码剖析</h1>
<h3 id="2-4-1-协程G结构体">2.4.1 协程G结构体</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/runtime2.go</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line">    stack       stack   <span class="comment">// 保存当前协程栈的上界和下界</span></span><br><span class="line">    <span class="comment">// stackguard0 是对比 Go 栈增长的 prologue 的栈指针</span></span><br><span class="line">    <span class="comment">// 如果 sp 寄存器比 stackguard0 小（由于栈往低地址方向增长），会触发栈拷贝和调度</span></span><br><span class="line">    <span class="comment">// 通常情况下：stackguard0 = stack.lo + StackGuard，但被抢占时会变为 StackPreempt</span></span><br><span class="line">    stackguard0 <span class="type">uintptr</span> <span class="comment">// offset known to liblink</span></span><br><span class="line">    <span class="comment">// stackguard1 是对比 C 栈增长的 prologue 的栈指针</span></span><br><span class="line">    <span class="comment">// 当位于 g0 和 gsignal 栈上时，值为 stack.lo + StackGuard</span></span><br><span class="line">    <span class="comment">// 在其他栈上值为 ~0 用于触发 morestackc (并 crash) 调用</span></span><br><span class="line">    stackguard1 <span class="type">uintptr</span> <span class="comment">// offset known to liblink</span></span><br><span class="line">    _panic    *_panic   <span class="comment">// 这个协程里面的panic列表</span></span><br><span class="line">    _defer    *_defer   <span class="comment">// 这个协程里面的defer列表</span></span><br><span class="line">    m           *m      <span class="comment">// 当前g占用的线程m</span></span><br><span class="line">    sched       gobuf   <span class="comment">// 协程调度的上下文数据 保存PC，SP等寄存器，协程切换的参数，描述了执行现场</span></span><br><span class="line">    atomicstatus atomic.Uint32 <span class="comment">// G 的状态</span></span><br><span class="line">    syscallsp   <span class="type">uintptr</span> <span class="comment">// if status==Gsyscall, syscallsp = sched.sp to use during gc</span></span><br><span class="line">    syscallpc   <span class="type">uintptr</span> <span class="comment">// if status==Gsyscall, syscallpc = sched.pc to use during gc</span></span><br><span class="line">    stktopsp    <span class="type">uintptr</span> <span class="comment">// expected sp at top of stack, to check in traceback</span></span><br><span class="line">    goid        <span class="type">uint64</span>  <span class="comment">// 协程唯一id？</span></span><br><span class="line">    preempt     <span class="type">bool</span>    <span class="comment">// 是否可以抢占 preemption signal, duplicates stackguard0 = stackpreempt</span></span><br><span class="line">    preemptStop   <span class="type">bool</span> <span class="comment">// transition to _Gpreempted on preemption; otherwise, just deschedule</span></span><br><span class="line">    preemptShrink <span class="type">bool</span> <span class="comment">// shrink stack at synchronous safe point</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>每个协程创建的时候都分配了大小为2k的栈，用stack进行保存，栈范围为[stack.lo, stack.hi),</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/runtime2.go</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> stack <span class="keyword">struct</span> &#123;</span><br><span class="line">    lo <span class="type">uintptr</span> <span class="comment">// 栈顶，低地址</span></span><br><span class="line">    hi <span class="type">uintptr</span> <span class="comment">// 栈底，高地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>gobuf结构体用来保存协程切换的上下文信息，协程创建时可以保存协程的初始状态，协程被调度时，可以将当前协程的运行状态保存起来，方便后续恢复，从这个结构体可以看出，协程的切换开销很小</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/runtime2.go</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> gobuf <span class="keyword">struct</span> &#123;</span><br><span class="line">    sp   <span class="type">uintptr</span> <span class="comment">// sp堆栈寄存器，永远指向栈顶位置</span></span><br><span class="line">    pc   <span class="type">uintptr</span> <span class="comment">// pc寄存器的值</span></span><br><span class="line">    g    guintptr</span><br><span class="line">    ctxt unsafe.Pointer <span class="comment">// gc时候使用</span></span><br><span class="line">    ret  <span class="type">uintptr</span> <span class="comment">// ret用来保存系统调用的返回值</span></span><br><span class="line">    lr   <span class="type">uintptr</span> <span class="comment">// 保存返回地址</span></span><br><span class="line">    bp   <span class="type">uintptr</span> <span class="comment">// 基址寄存器，配合sp寄存器使用，某一时刻的栈顶位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>协程状态用atomic原子变量来保存，由如下几种状态</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    _Gidle = <span class="literal">iota</span> <span class="comment">// 0</span></span><br><span class="line">    _Grunnable <span class="comment">// 1 在运行队列中等待被调度</span></span><br><span class="line">    _Grunning <span class="comment">// 2 正在m上运行</span></span><br><span class="line">    _Gsyscall <span class="comment">// 3 正在执行系统调用</span></span><br><span class="line">    _Gwaiting <span class="comment">// 4 阻塞状态</span></span><br><span class="line">    _Gdead <span class="comment">// 6 协程处于被销毁状态</span></span><br><span class="line">    _Gcopystack <span class="comment">// 8 栈扩容或缩容阶段</span></span><br><span class="line">    _Gpreempted <span class="comment">// 9 g被抢占后的状态</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="2-4-2-线程M结构体">2.4.2 线程M结构体</h3>
<p>结构体m保存了M自身使用的栈信息、当前正在M上执行的G，以及绑定M的P指针等。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/runtime2.go</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 当前线程执行调度逻辑的协程g0的指针，g0同时使用是系统栈</span></span><br><span class="line">    g0      *g    </span><br><span class="line">    morebuf gobuf  <span class="comment">// gobuf arg to morestack</span></span><br><span class="line">    gsignal       *g                <span class="comment">// 每个m都创建了一个信号处理的协程gsignal</span></span><br><span class="line">    sigmask       sigset            <span class="comment">// 存储信号掩码，当前线程的信号屏蔽字</span></span><br><span class="line">    ...</span><br><span class="line">    tls           [tlsSlots]<span class="type">uintptr</span> <span class="comment">// 线程本地存储 thread-local storage</span></span><br><span class="line">    mstartfn      <span class="function"><span class="keyword">func</span><span class="params">()</span></span>            <span class="comment">// M的起始函数，go协程执行的函数</span></span><br><span class="line">    curg          *g       <span class="comment">// 指向当前运行的协程g</span></span><br><span class="line">    p             puintptr <span class="comment">// 指向当前绑定的处理器p</span></span><br><span class="line">    nextp         puintptr</span><br><span class="line">    oldp          puintptr <span class="comment">// 系统调用之前本协程绑定的P，系统调用结束之后首先找这个P</span></span><br><span class="line">    id            <span class="type">int64</span>     <span class="comment">// 线程id</span></span><br><span class="line">    spinning      <span class="type">bool</span>      <span class="comment">// M当前状态 自旋态表示在寻址可运行的g</span></span><br><span class="line">    blocked       <span class="type">bool</span>      <span class="comment">// M当前状态 阻塞态 m is blocked on a note</span></span><br><span class="line">    alllink       *m        <span class="comment">// on allm 记录所有工作线程的一个链表</span></span><br></pre></td></tr></table></figure>
<p><strong>g0协程：</strong> 需要注意的是,每个线程m创建时就会创建一个名为g0的协程，该协程使用的是线程的系统栈，负责普通协程在M上面的调度。协程切换时，也是先从当前协程切换到g0协程执行调度代码,g0找到下一个执行的协程之后，再切换到新的协程去执行。<br>
<strong>m0线程：</strong> m0线程便是Go进程启动的初始线程，在进程启动函数rt0_go中将初始线程其赋值给m0，将系统栈赋值给g0，同时完成m0和g0的绑定。</p>
<h3 id="2-4-3-处理器P结构体">2.4.3 处理器P结构体</h3>
<p>P中保存了本地协程运行队列，协程运行所需的资源如内存，运行线程等</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">    id          <span class="type">int32</span></span><br><span class="line">    status      <span class="type">uint32</span>      <span class="comment">// 当前p的状态，空闲、运行、陷入系统调用、停止、死亡</span></span><br><span class="line">    link        puintptr</span><br><span class="line">    schedtick   <span class="type">uint32</span>     <span class="comment">// 协程调度次数计数器（10ms没有调度过，就会启动抢占）</span></span><br><span class="line">    syscalltick <span class="type">uint32</span>     <span class="comment">// 系统调用计数器</span></span><br><span class="line">    sysmontick  sysmontick <span class="comment">// 监听线程sysmon监听次数计数器</span></span><br><span class="line">    m           muintptr   <span class="comment">// 当前p关联的内核线程m</span></span><br><span class="line">    mcache      *mcache     <span class="comment">// 用于分配微小对象和小对象的一个块的缓存空间，里面有各种不同等级的span</span></span><br><span class="line">    pcache      pageCache   <span class="comment">// 一个chunk大小（512kb）的内存空间，用来对堆上内存分配的缓存优化达到无锁访问的目的</span></span><br><span class="line">    raceprocctx <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    deferpool    []*_defer <span class="comment">// pool of available defer structs (see panic.go)</span></span><br><span class="line">    deferpoolbuf [<span class="number">32</span>]*_defer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以分配给g的id的缓存，每次会一次性申请16个</span></span><br><span class="line">    goidcache    <span class="type">uint64</span></span><br><span class="line">    goidcacheend <span class="type">uint64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存可运行的g本地队列，后续可以无锁访问</span></span><br><span class="line">    runqhead <span class="type">uint32</span></span><br><span class="line">    runqtail <span class="type">uint32</span></span><br><span class="line">    runq     [<span class="number">256</span>]guintptr</span><br><span class="line">    runnext guintptr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于复用已经需要销毁的g，将状态改为Gdead，不直接销毁而是存储起来复用</span></span><br><span class="line">    gFree <span class="keyword">struct</span> &#123;</span><br><span class="line">        gList</span><br><span class="line">        n <span class="type">int32</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    sudogcache []*sudog</span><br><span class="line">    sudogbuf   [<span class="number">128</span>]*sudog</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从全局heap中分配128个mspan对象</span></span><br><span class="line">    mspancache <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="built_in">len</span> <span class="type">int</span></span><br><span class="line">        buf [<span class="number">128</span>]*mspan</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从结构体中可知，P中保存了一个长度为256的协程数组，可以无锁访问。当p的队列满了之后，创建的协程g将会放到全局队列里面。P中也保存了当前关联的内核线程m指针<br>
P中缓存了协程g用于分配的内存块，协程首先从当前p的内存块分配内存，不够再由P去heap中申请新的内存块</p>
<h3 id="2-4-5-协程G的创建过程">2.4.5 协程G的创建过程</h3>
<p>协程由关键字go创建，go关键字最终会解析成函数调用runtime.newproc(fn *funcval)，过程如下：</p>
<ol>
<li>
<p>在systemstack函数里面执行核心逻辑。systemstack作用是切换到g0系统栈，在系统栈上面执行核心逻辑，执行完成后systemstack函数会切换回当前协程的栈,<br>
    <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// src/runtime/proc.go</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 协程的启动函数</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">newproc</span><span class="params">(fn *funcval)</span></span> &#123;</span><br><span class="line">        gp := getg()</span><br><span class="line">        pc := getcallerpc()</span><br><span class="line">        <span class="comment">// 切换到g0栈执行，执行完成后切回原来的栈空间</span></span><br><span class="line">        systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// 核心逻辑创建协程</span></span><br><span class="line">            newg := newproc1(fn, gp, pc)</span><br><span class="line">            pp := getg().m.p.ptr()</span><br><span class="line">            <span class="comment">// 将创建的协程保存到当前p中，局部性原理，放满了就放到全局队列</span></span><br><span class="line">            runqput(pp, newg, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> mainStarted &#123;</span><br><span class="line">                <span class="comment">// 在所有的空闲P链表里面，唤醒第一个P，并调度M（没有则创建）去运行这个P</span></span><br><span class="line">                wakep()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>协程创建的核心逻辑再runtime.newproc1函数中<br>
    <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// src/runtime/newproc1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">newproc1</span><span class="params">(fn *funcval, callergp *g, callerpc <span class="type">uintptr</span>)</span></span> *g &#123;</span><br><span class="line">        <span class="keyword">if</span> fn == <span class="literal">nil</span> &#123;</span><br><span class="line">            fatal(<span class="string">&quot;go of nil func value&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        mp := acquirem() <span class="comment">// disable preemption because we hold M and P in local vars.</span></span><br><span class="line">        pp := mp.p.ptr()</span><br><span class="line">        <span class="comment">// 从当前P的gFree协程队列里面取一个来复用，当前P的gFree如果为空，就从全局gFree队列里面取</span></span><br><span class="line">        newg := gfget(pp)</span><br><span class="line">        <span class="keyword">if</span> newg == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 新建一个栈大小为2k的g对象，将栈顶和栈底保存到newg.stack里面</span></span><br><span class="line">            newg = malg(_StackMin)</span><br><span class="line">            casgstatus(newg, _Gidle, _Gdead)</span><br><span class="line">            <span class="comment">// 将新创建的g的指针保存到全局的allgs数组中，新创建的g未防止被gc扫描，将g的状态改为Gdead</span></span><br><span class="line">            allgadd(newg)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        totalSize := <span class="type">uintptr</span>(<span class="number">4</span>*goarch.PtrSize + sys.MinFrameSize) <span class="comment">// extra space in case of reads slightly beyond frame</span></span><br><span class="line">        totalSize = alignUp(totalSize, sys.StackAlign)</span><br><span class="line">        sp := newg.stack.hi - totalSize</span><br><span class="line">        spArg := sp</span><br><span class="line">        <span class="keyword">if</span> usesLR &#123;</span><br><span class="line">            <span class="comment">// caller&#x27;s LR</span></span><br><span class="line">            *(*<span class="type">uintptr</span>)(unsafe.Pointer(sp)) = <span class="number">0</span></span><br><span class="line">            prepGoExitFrame(sp)</span><br><span class="line">            spArg += sys.MinFrameSize</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化g对象的gobuf，调度用的sp、pc、任务函数等</span></span><br><span class="line">        memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))</span><br><span class="line">        newg.sched.sp = sp</span><br><span class="line">        newg.stktopsp = sp</span><br><span class="line">        <span class="comment">// 这里先将pc指向goexit地址，后续这个pc值会在gostartcallfn函数中塞在sp中，也就是栈底位置，而这个位置是go函数调用的return addr，所以协程任务函数执行完成后会执行goexit函数</span></span><br><span class="line">        newg.sched.pc = abi.FuncPCABI0(goexit) + sys.PCQuantum <span class="comment">// +PCQuantum so that previous instruction is in same function</span></span><br><span class="line">        newg.sched.g = guintptr(unsafe.Pointer(newg))</span><br><span class="line">        <span class="comment">// 填充sched这个gobuf结构体，设置newg.sched的堆栈指针sp，pc指向协程的任务函数fn</span></span><br><span class="line">        gostartcallfn(&amp;newg.sched, fn)</span><br><span class="line">        newg.gopc = callerpc</span><br><span class="line">        newg.ancestors = saveAncestors(callergp)</span><br><span class="line">        newg.startpc = fn.fn</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">        casgstatus(newg, _Gdead, _Grunnable)</span><br><span class="line">        gcController.addScannableStack(pp, <span class="type">int64</span>(newg.stack.hi-newg.stack.lo))</span><br><span class="line">        <span class="comment">// 分配goid</span></span><br><span class="line">        <span class="keyword">if</span> pp.goidcache == pp.goidcacheend &#123;</span><br><span class="line">            pp.goidcache = sched.goidgen.Add(_GoidCacheBatch)</span><br><span class="line">            pp.goidcache -= _GoidCacheBatch - <span class="number">1</span></span><br><span class="line">            pp.goidcacheend = pp.goidcache + _GoidCacheBatch</span><br><span class="line">        &#125;</span><br><span class="line">        newg.goid = pp.goidcache</span><br><span class="line">        pp.goidcache++</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">        releasem(mp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newg</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>协程创建完成后，将协程插入到当前M对应的P上面，也就是跟父协程在同一个P上面。</p>
</li>
<li>
<p>所有的空闲P链表里面，唤醒第一个P，并调度M（没有则创建）去运行这个P，调用链为wakep()–&gt;startm(pp *p, spinning bool)</p>
</li>
</ol>
<h3 id="2-4-6-协程G的退出过程">2.4.6 协程G的退出过程</h3>
<p>协程的创建过程中已经分析了，通过将goexit函数设置在协程栈底位置，使得协程执行完任务函数fn后会调用goexit函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/asm_arm64.s</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 大部分在协程上面运行的函数，最终的返回值都是指向goexit函数</span></span><br><span class="line">TEXT runtime·goexit(SB),NOSPLIT|NOFRAME|TOPFRAME,$<span class="number">0</span><span class="number">-0</span></span><br><span class="line">    MOVD    R0, R0  <span class="comment">// NOP</span></span><br><span class="line">    BL  runtime·goexit1(SB) <span class="comment">// does not return</span></span><br></pre></td></tr></table></figure>
<p>runtime.goexit最终会执行runtime.goexit1函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/proc.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goexit1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        racegoend()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">        traceGoEnd()</span><br><span class="line">    &#125;</span><br><span class="line">    mcall(goexit0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>runtime.goexit1函数内，会通过mcall来调用goexit0函数，mcall函数和之前的systemstack函数类似，都是用汇编写的，mcall函数将当前栈切换到所在m的g0的栈，但结束之后不会切会原来的栈。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/asm_arm64.s</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// mcall用于切换到m所在g0的栈，由于不会再次切换到之前协程的栈，所以，mcall执行的函数必须没有返回</span></span><br><span class="line">TEXT runtime·mcall&lt;ABIInternal&gt;(SB), NOSPLIT|NOFRAME, $<span class="number">0</span><span class="number">-8</span></span><br><span class="line">    MOVD    R0, R26             <span class="comment">// context</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save caller state in g-&gt;sched</span></span><br><span class="line">    <span class="comment">// 保存当前协程的状态到gobuf里面</span></span><br><span class="line">    MOVD    RSP, R0</span><br><span class="line">    MOVD    R0, (g_sched+gobuf_sp)(g)</span><br><span class="line">    MOVD    R29, (g_sched+gobuf_bp)(g)</span><br><span class="line">    MOVD    LR, (g_sched+gobuf_pc)(g)</span><br><span class="line">    MOVD    $<span class="number">0</span>, (g_sched+gobuf_lr)(g)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Switch to m-&gt;g0 &amp; its stack, call fn.</span></span><br><span class="line">    MOVD    g, R3</span><br><span class="line">    MOVD    g_m(g), R8</span><br><span class="line">    MOVD    m_g0(R8), g <span class="comment">// 将g切换到g0，使得后面g.sched是使用的g0的栈</span></span><br><span class="line">    BL  runtime·save_g(SB)</span><br><span class="line">    CMP g, R3       <span class="comment">// 保证调用者g不是g0</span></span><br><span class="line">    BNE <span class="number">2</span>(PC)</span><br><span class="line">    B   runtime·badmcall(SB)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    MOVD    (g_sched+gobuf_sp)(g), R0</span><br><span class="line">    MOVD    R0, RSP <span class="comment">// sp = m-&gt;g0-&gt;sched.sp</span></span><br><span class="line">    MOVD    (g_sched+gobuf_bp)(g), R29</span><br><span class="line">    MOVD    R3, R0              <span class="comment">// arg = g</span></span><br><span class="line">    MOVD    $<span class="number">0</span>, <span class="number">-16</span>(RSP)            <span class="comment">// dummy LR</span></span><br><span class="line">    SUB $<span class="number">16</span>, RSP</span><br><span class="line">    MOVD    <span class="number">0</span>(R26), R4          <span class="comment">// code pointer</span></span><br><span class="line">    BL  (R4)                    <span class="comment">// 调用fn函数，该函数不会返回，不然返回后会调用badmcall2</span></span><br><span class="line">    B   runtime·badmcall2(SB)</span><br></pre></td></tr></table></figure>
<p>mcall函数使用g0栈调用goexit0，并最终在goexit0里面执行循环，不会返回</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/proc.go</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goexit0</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">    mp := getg().m</span><br><span class="line">    pp := mp.p.ptr()</span><br><span class="line">    <span class="comment">// 将当前协程状态改为Gdead</span></span><br><span class="line">    casgstatus(gp, _Grunning, _Gdead)</span><br><span class="line">    gcController.addScannableStack(pp, -<span class="type">int64</span>(gp.stack.hi-gp.stack.lo))</span><br><span class="line">    <span class="keyword">if</span> isSystemGoroutine(gp, <span class="literal">false</span>) &#123;</span><br><span class="line">        sched.ngsys.Add(<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    gp.m = <span class="literal">nil</span></span><br><span class="line">    locked := gp.lockedm != <span class="number">0</span></span><br><span class="line">    gp.lockedm = <span class="number">0</span></span><br><span class="line">    mp.lockedg = <span class="number">0</span></span><br><span class="line">    gp.preemptStop = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 修改gp的各项值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &amp;&amp; gp.gcAssistBytes &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// gc 设置</span></span><br><span class="line">        assistWorkPerByte := gcController.assistWorkPerByte.Load()</span><br><span class="line">        scanCredit := <span class="type">int64</span>(assistWorkPerByte * <span class="type">float64</span>(gp.gcAssistBytes))</span><br><span class="line">        gcController.bgScanCredit.Add(scanCredit)</span><br><span class="line">        gp.gcAssistBytes = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将g设置过不使用，并将g插入到当前p的gFree队列里面，方便后面创建协程的时候复用这些协程</span></span><br><span class="line">    dropg()</span><br><span class="line">    gfput(pp, gp)</span><br><span class="line">    <span class="comment">// mcall已经切换到了g0，在g0栈里面执行下一次协程调度。</span></span><br><span class="line">    schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，最终goexit0函数会执行协程调度代码，从而在当前协程g退出之后，m开始执行在g0栈上开始执行下一轮调度</p>
<h3 id="2-4-7-协程G的切换过程">2.4.7 协程G的切换过程</h3>
<p>当协程调度完成，寻找到下一个要执行的协程之后，需要切换到新协程执行，切换的核心逻辑便是用汇编写的gogo函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/asm_386.s</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// void gogo(gpbuf Gobuf*)</span></span><br><span class="line"><span class="comment">// restore state from Gobuf; longjmp</span></span><br><span class="line">TEXT runtime·gogo(SB), NOSPLIT, $<span class="number">0</span><span class="number">-4</span></span><br><span class="line">    MOVL    buf+<span class="number">0</span>(FP), BX       <span class="comment">// gobuf</span></span><br><span class="line">    MOVL    gobuf_g(BX), DX</span><br><span class="line">    MOVL    <span class="number">0</span>(DX), CX       <span class="comment">// make sure g != nil</span></span><br><span class="line">    JMP gogo&lt;&gt;(SB)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TEXT gogo&lt;&gt;(SB), NOSPLIT, $<span class="number">0</span></span><br><span class="line">    get_tls(CX)</span><br><span class="line">    MOVL    DX, g(CX)</span><br><span class="line">    MOVL    gobuf_sp(BX), SP    <span class="comment">// restore SP 将SP寄存器的值设置为新协程的gp.sched.sp</span></span><br><span class="line">    MOVL    gobuf_ret(BX), AX   <span class="comment">//</span></span><br><span class="line">    MOVL    gobuf_ctxt(BX), DX</span><br><span class="line">    MOVL    $<span class="number">0</span>, gobuf_sp(BX)    <span class="comment">// clear to help garbage collector</span></span><br><span class="line">    MOVL    $<span class="number">0</span>, gobuf_ret(BX)</span><br><span class="line">    MOVL    $<span class="number">0</span>, gobuf_ctxt(BX)</span><br><span class="line">    MOVL    gobuf_pc(BX), BX    <span class="comment">// 将要JMP过去的位置设置为新协程的gp.sched.pc</span></span><br><span class="line">    JMP BX</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-4-8-协程G的栈内存分配">2.4.8 协程G的栈内存分配</h3>
<p><a target="_blank" rel="noopener" href="https://golang.design/under-the-hood/zh-cn/part2runtime/ch06sched/stack/">https://golang.design/under-the-hood/zh-cn/part2runtime/ch06sched/stack/</a></p>
<h3 id="2-4-9-处理器P的创建过程">2.4.9 处理器P的创建过程</h3>
<p>处理器的创建是在初始化阶段schedinit函数中创建的，通过系统调用获取当前cpu个数，也可也环境变量来配置需要创建多少个P</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/proc.go</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    sched.lastpoll.Store(nanotime())</span><br><span class="line">    procs := ncpu</span><br><span class="line">    <span class="keyword">if</span> n, ok := atoi32(gogetenv(<span class="string">&quot;GOMAXPROCS&quot;</span>)); ok &amp;&amp; n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        procs = n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> procresize(procs) != <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;unknown runnable goroutine during bootstrap&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// scheinit里面的全局变量 ncpu=getncpu()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getncpu</span><span class="params">()</span></span> <span class="type">int32</span> &#123;</span><br><span class="line">    mib := [<span class="number">2</span>]<span class="type">uint32</span>&#123;_CTL_HW, _HW_NCPU&#125;</span><br><span class="line">    out := <span class="type">uint32</span>(<span class="number">0</span>)</span><br><span class="line">    nout := unsafe.Sizeof(out)</span><br><span class="line">    ret := sysctl(&amp;mib[<span class="number">0</span>], <span class="number">2</span>, (*<span class="type">byte</span>)(unsafe.Pointer(&amp;out)), &amp;nout, <span class="literal">nil</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> ret &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">int32</span>(out)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建P的核心函数是procesize(proc)，初始化和后续修改P的数据也都是调用该函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">procresize</span><span class="params">(nprocs <span class="type">int32</span>)</span></span> *p &#123;</span><br><span class="line">    <span class="comment">// 创建或者修改P的数量的时候，需要全局加锁，且STW</span></span><br><span class="line">    assertLockHeld(&amp;sched.lock)</span><br><span class="line">    assertWorldStopped()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Grow allp if necessary.</span></span><br><span class="line">    <span class="keyword">if</span> nprocs &gt; <span class="type">int32</span>(<span class="built_in">len</span>(allp)) &#123;</span><br><span class="line">        lock(&amp;allpLock)</span><br><span class="line">        <span class="keyword">if</span> nprocs &lt;= <span class="type">int32</span>(<span class="built_in">cap</span>(allp)) &#123;</span><br><span class="line">            <span class="comment">// 如果是缩小p的数量，直接从之前的allp里面截取所需的长度</span></span><br><span class="line">            allp = allp[:nprocs]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nallp := <span class="built_in">make</span>([]*p, nprocs)</span><br><span class="line">            <span class="comment">// 创建一个新的nallp，如果之前的allp里面已经有数据，全部拷贝过去</span></span><br><span class="line">            <span class="built_in">copy</span>(nallp, allp[:<span class="built_in">cap</span>(allp)])</span><br><span class="line">            allp = nallp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize new P&#x27;s</span></span><br><span class="line">    <span class="keyword">for</span> i := old; i &lt; nprocs; i++ &#123;</span><br><span class="line">        pp := allp[i]</span><br><span class="line">        <span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">            pp = <span class="built_in">new</span>(p)</span><br><span class="line">        &#125;</span><br><span class="line">        pp.init(i)</span><br><span class="line">        atomicstorep(unsafe.Pointer(&amp;allp[i]), unsafe.Pointer(pp))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="keyword">if</span> gp.m.p != <span class="number">0</span> &amp;&amp; gp.m.p.ptr().id &lt; nprocs &#123;</span><br><span class="line">        <span class="comment">//如果当前p的id小于当前p的数量，则继续使用当前p</span></span><br><span class="line">        gp.m.p.ptr().status = _Prunning</span><br><span class="line">        gp.m.p.ptr().mcache.prepareForSweep()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果</span></span><br><span class="line">        <span class="keyword">if</span> gp.m.p != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">                <span class="comment">// Pretend that we were descheduled</span></span><br><span class="line">                <span class="comment">// and then scheduled again to keep</span></span><br><span class="line">                <span class="comment">// the trace sane.</span></span><br><span class="line">                traceGoSched()</span><br><span class="line">                traceProcStop(gp.m.p.ptr())</span><br><span class="line">            &#125;</span><br><span class="line">            gp.m.p.ptr().m = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        gp.m.p = <span class="number">0</span></span><br><span class="line">        pp := allp[<span class="number">0</span>]</span><br><span class="line">        pp.m = <span class="number">0</span></span><br><span class="line">        pp.status = _Pidle</span><br><span class="line">        acquirep(pp)</span><br><span class="line">        <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">            traceGoStart()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// g.m.p is now set, so we no longer need mcache0 for bootstrapping.</span></span><br><span class="line">    mcache0 = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// p的数量缩容，多的需要销毁</span></span><br><span class="line">    <span class="keyword">for</span> i := nprocs; i &lt; old; i++ &#123;</span><br><span class="line">        pp := allp[i]</span><br><span class="line">        pp.destroy()</span><br><span class="line">        <span class="comment">// can&#x27;t free P itself because it can be referenced by an M in syscall</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> runnablePs *p</span><br><span class="line">    <span class="keyword">for</span> i := nprocs - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        pp := allp[i]</span><br><span class="line">        <span class="keyword">if</span> gp.m.p.ptr() == pp &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        pp.status = _Pidle</span><br><span class="line">        <span class="keyword">if</span> runqempty(pp) &#123;</span><br><span class="line">            pidleput(pp, now)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 把当前空闲的m绑定到p上面，mget()会循环从空闲m队列里面取，没有了返回nil</span></span><br><span class="line">            pp.m.set(mget())</span><br><span class="line">            pp.link.set(runnablePs)</span><br><span class="line">            runnablePs = pp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> runnablePs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-9-线程M的创建过程">2.4.9 线程M的创建过程</h3>
<p>首先需要明确的是m0线程是进程启动就创建的初始线程，除m0外的线程m1，m2…才是通过本节所讨论的创建方式创建的<br>
在前面的<strong>协程G的创建过程</strong>一节中，我们分析了创建了协程之后，会将新协程插入到P中，然后调用startm来获取一个m运行P，当没有空闲的m时，则会调用newm(fn func(), pp *p, id int64)创建一个m</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/proc.go</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newm</span><span class="params">(fn <span class="keyword">func</span>()</span></span>, pp *p, id <span class="type">int64</span>) &#123;</span><br><span class="line">    acquirem()</span><br><span class="line">    <span class="comment">// 创建一个m结构体，m的起始函数为fn</span></span><br><span class="line">    mp := allocm(pp, fn, id)</span><br><span class="line">    mp.nextp.set(pp)</span><br><span class="line">    mp.sigmask = initSigmask</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 用m参数创建一个系统线程</span></span><br><span class="line">    newm1(mp)</span><br><span class="line">    releasem(getg().m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>allocm函数中会创建和初始化一个m结构体，线程的创建过程在</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pp:需要初始化绑定待创建的m的p；fn：线程启动执行的函数，如自旋函数mspinning；id：待创建线程m的id</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allocm</span><span class="params">(pp *p, fn <span class="keyword">func</span>()</span></span>, id <span class="type">int64</span>) *m &#123;</span><br><span class="line">    allocmLock.rlock()</span><br><span class="line">     <span class="comment">// 将_g_对应的m的locks加1，防止被抢占</span></span><br><span class="line">    acquirem()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="keyword">if</span> gp.m.p == <span class="number">0</span> &#123;</span><br><span class="line">        acquirep(pp) <span class="comment">// temporarily borrow p for mallocs in this function</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个m结构体，并设置起始函数是fn</span></span><br><span class="line">    mp := <span class="built_in">new</span>(m)</span><br><span class="line">    mp.mstartfn = fn</span><br><span class="line">    mcommoninit(mp, id)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> iscgo || mStackIsSystemAllocated() &#123;</span><br><span class="line">        mp.g0 = malg(<span class="number">-1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个设置栈大小为8M的g结构体赋值给m的g0</span></span><br><span class="line">        mp.g0 = malg(<span class="number">8192</span> * sys.StackGuardMultiplier)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个m的g0和自身进行绑定</span></span><br><span class="line">    mp.g0.m = mp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> pp == gp.m.p.ptr() &#123;</span><br><span class="line">        releasep()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解除_g_的m的禁止抢占状态</span></span><br><span class="line">    releasem(gp.m)</span><br><span class="line">    allocmLock.runlock()</span><br><span class="line">    <span class="keyword">return</span> mp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newm1</span><span class="params">(mp *m)</span></span> &#123;</span><br><span class="line">    execLock.rlock() <span class="comment">// Prevent process clone.</span></span><br><span class="line">    newosproc(mp)</span><br><span class="line">    execLock.runlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>newm1最终调用newosproc函数，在该函数里面通过系统调用pthread_create创建一个系统线程，并执行runtime.mstart来启动m上面的调度器进行调度</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/os_darwin.go</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newosproc</span><span class="params">(mp *m)</span></span> &#123;</span><br><span class="line">    stk := unsafe.Pointer(mp.g0.stack.hi)</span><br><span class="line">    <span class="keyword">if</span> <span class="literal">false</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;newosproc stk=&quot;</span>, stk, <span class="string">&quot; m=&quot;</span>, mp, <span class="string">&quot; g=&quot;</span>, mp.g0, <span class="string">&quot; id=&quot;</span>, mp.id, <span class="string">&quot; ostk=&quot;</span>, &amp;mp, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize an attribute object.</span></span><br><span class="line">    <span class="keyword">var</span> attr pthreadattr</span><br><span class="line">    <span class="keyword">var</span> err <span class="type">int32</span></span><br><span class="line">    err = pthread_attr_init(&amp;attr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="number">0</span> &#123;</span><br><span class="line">        write(<span class="number">2</span>, unsafe.Pointer(&amp;failthreadcreate[<span class="number">0</span>]), <span class="type">int32</span>(<span class="built_in">len</span>(failthreadcreate)))</span><br><span class="line">        exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find out OS stack size for our own stack guard.</span></span><br><span class="line">    <span class="comment">// 获取线程的系统栈大小赋值给g0</span></span><br><span class="line">    <span class="keyword">var</span> stacksize <span class="type">uintptr</span></span><br><span class="line">    <span class="keyword">if</span> pthread_attr_getstacksize(&amp;attr, &amp;stacksize) != <span class="number">0</span> &#123;</span><br><span class="line">        write(<span class="number">2</span>, unsafe.Pointer(&amp;failthreadcreate[<span class="number">0</span>]), <span class="type">int32</span>(<span class="built_in">len</span>(failthreadcreate)))</span><br><span class="line">        exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    mp.g0.stack.hi = stacksize <span class="comment">// 设置hi为size， for mstart</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过系统调用创建线程，使用mstart_stub，而mstart_stub最终会调用runtime.mstart</span></span><br><span class="line">    <span class="comment">// Finally, create the thread. It starts at mstart_stub, which does some low-level</span></span><br><span class="line">    <span class="comment">// setup and then calls mstart.</span></span><br><span class="line">    <span class="keyword">var</span> oset sigset</span><br><span class="line">    sigprocmask(_SIG_SETMASK, &amp;sigset_all, &amp;oset)</span><br><span class="line">    err = pthread_create(&amp;attr, abi.FuncPCABI0(mstart_stub), unsafe.Pointer(mp))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pthread_create创建的线程执行的是mstart_stub，并最终执行runtime.mstart。在go程序启动时，初始线程（m0）执行rt0_go代码最终也是会执行到mstart开启调度</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TEXT runtime·mstart_stub(SB),NOSPLIT,$<span class="number">0</span></span><br><span class="line">    PUSH_REGS_HOST_TO_ABI0()</span><br><span class="line">    MOVQ    m_g0(DI), DX <span class="comment">// g</span></span><br><span class="line">    MOVQ    DX, <span class="number">0x30</span>(GS)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    CALL    runtime·mstart(SB)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    POP_REGS_HOST_TO_ABI0()</span><br><span class="line">    XORL    AX, AX</span><br><span class="line">    RET</span><br></pre></td></tr></table></figure>
<h3 id="2-4-10-线程M的启动过程">2.4.10 线程M的启动过程</h3>
<p>线程M的启动在runtime.mstart中启动，但是该函数在汇编中直接调用了runtime.mstart0。无论是进程初始线程m0，还是后续我们通过newm创建的线程，都会进入该函数进行启动线程并最终陷入协程调度中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mstart0</span><span class="params">()</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// gp指向的是g0，newosproc中填充g0的hi为size</span></span><br><span class="line">    osStack := gp.stack.lo == <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> osStack &#123;</span><br><span class="line">        size := gp.stack.hi</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">            size = <span class="number">8192</span> * sys.StackGuardMultiplier</span><br><span class="line">        &#125;</span><br><span class="line">        gp.stack.hi = <span class="type">uintptr</span>(noescape(unsafe.Pointer(&amp;size)))</span><br><span class="line">        gp.stack.lo = gp.stack.hi - size + <span class="number">1024</span></span><br><span class="line">    &#125;</span><br><span class="line">    gp.stackguard0 = gp.stack.lo + _StackGuard</span><br><span class="line">    gp.stackguard1 = gp.stackguard0</span><br><span class="line">    mstart1()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> mStackIsSystemAllocated() &#123;</span><br><span class="line">        osStack = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    mexit(osStack)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mstart0会调用mstart1来启动调度</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mstart1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// 一定是g0</span></span><br><span class="line">    <span class="keyword">if</span> gp != gp.m.g0 &#123;</span><br><span class="line">        throw(<span class="string">&quot;bad runtime·mstart&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// g的gobuf结构体sched保存当前上下文</span></span><br><span class="line">    gp.sched.g = guintptr(unsafe.Pointer(gp))</span><br><span class="line">    gp.sched.pc = getcallerpc()</span><br><span class="line">    gp.sched.sp = getcallersp()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    asminit()</span><br><span class="line">    <span class="comment">// 初始化m并设置m.g0的stack</span></span><br><span class="line">    minit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于m0线程，即进程主线程，需要注册一些信号处理函数</span></span><br><span class="line">    <span class="keyword">if</span> gp.m == &amp;m0 &#123;</span><br><span class="line">        mstartm0()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对于m0线程，mstartfn没有设置过？自己创建的m，可以不设置，也可以设置为自旋</span></span><br><span class="line">    <span class="keyword">if</span> fn := gp.m.mstartfn; fn != <span class="literal">nil</span> &#123;</span><br><span class="line">        fn()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> gp.m != &amp;m0 &#123;</span><br><span class="line">        acquirep(gp.m.nextp.ptr())</span><br><span class="line">        gp.m.nextp = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时一定是在g0上面执行调度</span></span><br><span class="line">    schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-5-调度器源码分析">2.5 调度器源码分析</h2>
<h3 id="2-5-1-系统全局变量">2.5.1 系统全局变量</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 存储所有的m，通过m.alllink相连。allm指向最新一个m，然后最新m的alllink指向之前一个m，直到m0</span></span><br><span class="line">    allm       *m      </span><br><span class="line">    gomaxprocs <span class="type">int32</span></span><br><span class="line">    ncpu       <span class="type">int32</span>    <span class="comment">// cpu核数</span></span><br><span class="line">    forcegc    forcegcstate</span><br><span class="line">    sched      schedt   <span class="comment">// 全局调度器</span></span><br><span class="line">    newprocs   <span class="type">int32</span>    </span><br><span class="line">    allpLock mutex</span><br><span class="line">    allp []*p           <span class="comment">// 保存所有的p指针</span></span><br><span class="line">    gcBgMarkWorkerPool lfstack</span><br><span class="line">    gcBgMarkWorkerCount <span class="type">int32</span></span><br></pre></td></tr></table></figure>
<h3 id="2-5-2-调度器schedt结构体">2.5.2 调度器schedt结构体</h3>
<p>保存调度器的状态信息以及全局空闲的M、P列表、goroutine的全局运行队列。该结构体变量sched是全局变量，保存了很多全局数据，多数要加锁修改。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> schedt <span class="keyword">struct</span> &#123;</span><br><span class="line">    goidgen   atomic.Uint64</span><br><span class="line">    lastpoll  atomic.Int64 <span class="comment">// time of last network poll, 0 if currently polling</span></span><br><span class="line">    pollUntil atomic.Int64 <span class="comment">// time to which current poll is sleeping</span></span><br><span class="line">    lock mutex</span><br><span class="line">    midle        muintptr <span class="comment">// 等待运行的空闲M列表</span></span><br><span class="line">    nmidle       <span class="type">int32</span>    <span class="comment">// 空闲M列表中元素个数</span></span><br><span class="line">    nmidlelocked <span class="type">int32</span>    <span class="comment">// number of locked m&#x27;s waiting for work</span></span><br><span class="line">    mnext        <span class="type">int64</span>    <span class="comment">// number of m&#x27;s that have been created and next M ID</span></span><br><span class="line">    maxmcount    <span class="type">int32</span>    <span class="comment">// 最多只能创建maxmcount个工作线程</span></span><br><span class="line">    nmsys        <span class="type">int32</span>    <span class="comment">// number of system m&#x27;s not counted for deadlock</span></span><br><span class="line">    nmfreed      <span class="type">int64</span>    <span class="comment">// cumulative number of freed m&#x27;s</span></span><br><span class="line">    ngsys atomic.Int32 <span class="comment">// number of system goroutines</span></span><br><span class="line">    pidle        puintptr <span class="comment">// 由空闲的p结构体对象组成的链表</span></span><br><span class="line">    npidle       atomic.Int32 <span class="comment">// 空闲的p结构体对象的数量</span></span><br><span class="line">    nmspinning   atomic.Int32  <span class="comment">// See &quot;Worker thread parking/unparking&quot; comment in proc.go.</span></span><br><span class="line">    needspinning atomic.Uint32 <span class="comment">// See &quot;Delicate dance&quot; comment in proc.go. Boolean. Must hold sched.lock to set to 1.</span></span><br><span class="line">    <span class="comment">// goroutine的全局运行队列</span></span><br><span class="line">    runq     gQueue</span><br><span class="line">    runqsize <span class="type">int32</span></span><br><span class="line">    disable <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="comment">// user disables scheduling of user goroutines.</span></span><br><span class="line">        user     <span class="type">bool</span></span><br><span class="line">        runnable gQueue <span class="comment">// pending runnable Gs</span></span><br><span class="line">        n        <span class="type">int32</span>  <span class="comment">// length of runnable</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// gFree是所有状态已经死亡（dead）的goroutine对应的g结构体对象组成的链表</span></span><br><span class="line">    <span class="comment">// 用于缓存g结构体对象，避免每次创建goroutine时都需要重新分配</span></span><br><span class="line">    gFree <span class="keyword">struct</span> &#123;</span><br><span class="line">        lock    mutex</span><br><span class="line">        stack   gList <span class="comment">// Gs with stacks</span></span><br><span class="line">        noStack gList <span class="comment">// Gs without stacks</span></span><br><span class="line">        n       <span class="type">int32</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Central cache of sudog structs.</span></span><br><span class="line">    sudoglock  mutex</span><br><span class="line">    sudogcache *sudog</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存已经退出的m，等待被释放</span></span><br><span class="line">    freem *m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    gcwaiting  atomic.Bool <span class="comment">// gc is waiting to run</span></span><br><span class="line">    stopwait   <span class="type">int32</span></span><br><span class="line">    stopnote   note</span><br><span class="line">    sysmonwait atomic.Bool</span><br><span class="line">    sysmonnote note</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-3-调度器初始化">2.5.3 调度器初始化</h3>
<p>在进程启动入口汇编函数rt0_go里面，完成m0和g0的绑定之后，就会调用调度器初始化函数schedinit，该函数是启动时由主线程m0调用，仅会执行一次</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    lockInit(&amp;sched.lock, lockRankSched)</span><br><span class="line">    <span class="comment">// lockInit......</span></span><br><span class="line">    gp := getg()</span><br><span class="line">    <span class="comment">// 系统线程M最多10000个</span></span><br><span class="line">    sched.maxmcount = <span class="number">10000</span></span><br><span class="line">    <span class="comment">// The world starts stopped.</span></span><br><span class="line">    worldStopped()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    moduledataverify()</span><br><span class="line">    stackinit()</span><br><span class="line">    mallocinit()</span><br><span class="line">    cpuinit()      <span class="comment">// must run before alginit</span></span><br><span class="line">    alginit()      <span class="comment">// maps, hash, fastrand must not be used before this call</span></span><br><span class="line">    fastrandinit() <span class="comment">// must run before mcommoninit</span></span><br><span class="line">    mcommoninit(gp.m, <span class="number">-1</span>)</span><br><span class="line">    gcinit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    lock(&amp;sched.lock)</span><br><span class="line">    sched.lastpoll.Store(nanotime())</span><br><span class="line">    procs := ncpu</span><br><span class="line">    <span class="keyword">if</span> n, ok := atoi32(gogetenv(<span class="string">&quot;GOMAXPROCS&quot;</span>)); ok &amp;&amp; n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        procs = n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调度器初始化时会创建cpu核数相同或者环境变量GOMAXPROCS个处理器P</span></span><br><span class="line">    <span class="keyword">if</span> procresize(procs) != <span class="literal">nil</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;unknown runnable goroutine during bootstrap&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// World is effectively started now, as P&#x27;s can run.</span></span><br><span class="line">    worldStarted()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-4-调度器启动调度流程">2.5.4 调度器启动调度流程</h3>
<p>启动协程调度主要是通过调用runtime.schedule,多个场景均会启动协程调度</p>
<ol>
<li>线程m启动时，无论时初始线程m0，还是后来创建的线程，线程都会执行runtime.mstart0初始化m，完成初始化之后便执行调度函数schedule</li>
<li>协程主动让渡其他协程执行Goched</li>
<li>发生协程抢占（preemptPark）的时候</li>
<li>当前协程执行协程挂起操作goyield</li>
<li>当前协程退出时（goexit）</li>
</ol>
<h3 id="2-5-5-调度器调度流程">2.5.5 调度器调度流程</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mp := getg().m</span><br><span class="line">top:</span><br><span class="line">    pp := mp.p.ptr()</span><br><span class="line">    pp.preempt = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调度策略 阻塞在查找可执行的g，用本地p的队列g，没有用全局队列的g</span></span><br><span class="line">    gp, inheritTime, tryWakeP := findRunnable() <span class="comment">// blocks until work is available</span></span><br><span class="line">    <span class="comment">// 在当前m上运行协程g，该函数不再返回</span></span><br><span class="line">    execute(gp, inheritTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>协程调度函数通过协程调度策略在寻找到可以运行的g之后，调用execute来执行该协程。具体调度策略都在findRunable中，后续会介绍</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入参： gp:待运行的g指针，inheritTime：是否要增加当前P的调度计数tick</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">(gp *g, inheritTime <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    mp := getg().m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assign gp.m before entering _Grunning so running Gs have an</span></span><br><span class="line">    <span class="comment">// M.</span></span><br><span class="line">    mp.curg = gp</span><br><span class="line">    gp.m = mp</span><br><span class="line">    casgstatus(gp, _Grunnable, _Grunning)</span><br><span class="line">    gp.waitsince = <span class="number">0</span></span><br><span class="line">    gp.preempt = <span class="literal">false</span></span><br><span class="line">    gp.stackguard0 = gp.stack.lo + _StackGuard</span><br><span class="line">    <span class="keyword">if</span> !inheritTime &#123;</span><br><span class="line">        mp.p.ptr().schedtick++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来从gobuf中恢复出协程执行状态并跳转到上一次指令处继续执行</span></span><br><span class="line">    gogo(&amp;gp.sched)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>execute将协程g设置为运行态之后，调用gogo切换到该协程,通过汇编语言，将CPU寄存器以及函数调用栈切换为g的sched中相关指针和协程栈</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/asm_arm64.s</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TEXT runtime·gogo(SB), NOSPLIT, $<span class="number">16</span><span class="number">-8</span></span><br><span class="line">    <span class="comment">// 0（FP）表示第一个参数，即buf=&amp;gp.sched</span></span><br><span class="line">    MOVW    buf+<span class="number">0</span>(FP), R1   <span class="comment">//gobuf</span></span><br><span class="line">    MOVW    gobuf_g(R1), R0</span><br><span class="line">    MOVW    <span class="number">0</span>(R0), R2   <span class="comment">// make sure g != nil</span></span><br><span class="line">    B   gogo&lt;&gt;(SB)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TEXT gogo&lt;&gt;(SB),NOSPLIT|NOFRAME,$<span class="number">0</span></span><br><span class="line">    BL  setg&lt;&gt;(SB)</span><br><span class="line">    <span class="comment">// 栈指针的切换，当前SP指向g0的栈，此处切换回gp.sched里面的sp指针，即完成了从g0到g的栈切换</span></span><br><span class="line">    MOVW    gobuf_sp(R1), R13   <span class="comment">// restore SP==R13</span></span><br><span class="line">    MOVW    gobuf_lr(R1), LR</span><br><span class="line">    MOVW    gobuf_ret(R1), R0</span><br><span class="line">    MOVW    gobuf_ctxt(R1), R7</span><br><span class="line">    <span class="comment">// 切换完成后，将sched里面的字段都清空</span></span><br><span class="line">    MOVW    $<span class="number">0</span>, R11</span><br><span class="line">    MOVW    R11, gobuf_sp(R1)   <span class="comment">// clear to help garbage collector</span></span><br><span class="line">    MOVW    R11, gobuf_ret(R1)</span><br><span class="line">    MOVW    R11, gobuf_lr(R1)</span><br><span class="line">    MOVW    R11, gobuf_ctxt(R1)</span><br><span class="line">    <span class="comment">// 将g.sched里面的pc值保存到BX里面，然后JMP跳转到该位置开始执行，开始执行协程g的代码</span></span><br><span class="line">    MOVW    gobuf_pc(R1), R11</span><br><span class="line">    CMP R11, R11 <span class="comment">// set condition codes for == test, needed by stack split</span></span><br><span class="line">    B   (R11)</span><br></pre></td></tr></table></figure>
<h3 id="2-5-6-协程调度策略">2.5.6 协程调度策略</h3>
<p>在调度器调度流程里面介绍，执行调度函数后，需要通过一定的策略找到下一个可运行的g，调度策略如下图：</p>
<!-- ![tmp.jpg](/img/runnable.jpg) -->
<p>调度策略主要是函数findRunnable()来完成</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回参数</span></span><br><span class="line"><span class="comment">// gp: 返回可运行的协程g，可能是P的本地队列里面的，也可能是从别的P窃取过来的，也可能是全局获取的，还可能是poll network唤醒的</span></span><br><span class="line"><span class="comment">// inheriTime: 是否要增加当前P的调度计数tick</span></span><br><span class="line"><span class="comment">// tryWakeP: 如果是GC或者trace的协程，需要去唤醒一个P来执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRunnable</span><span class="params">()</span></span> (gp *g, inheritTime, tryWakeP <span class="type">bool</span>) &#123;</span><br><span class="line">    mp := getg().m</span><br><span class="line">    <span class="comment">// 每隔61次从全局队列上获取一个可执行的G，P的本地队列都忙，全局协程也能执行。https://github.com/golang/go/issues/20168</span></span><br><span class="line">    <span class="keyword">if</span> pp.schedtick%<span class="number">61</span> == <span class="number">0</span> &amp;&amp; sched.runqsize &gt; <span class="number">0</span> &#123;</span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">        gp := globrunqget(pp, <span class="number">1</span>)</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// local runq</span></span><br><span class="line">    <span class="keyword">if</span> gp, inheritTime := runqget(pp); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gp, inheritTime, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// global runq</span></span><br><span class="line">    <span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">        gp := globrunqget(pp, <span class="number">0</span>)</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Poll network.</span></span><br><span class="line">    <span class="keyword">if</span> netpollinited() &amp;&amp; netpollWaiters.Load() &gt; <span class="number">0</span> &amp;&amp; sched.lastpoll.Load() != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> list := netpoll(<span class="number">0</span>); !list.empty() &#123; <span class="comment">// non-blocking</span></span><br><span class="line">            gp := list.pop()</span><br><span class="line">            injectglist(&amp;list)</span><br><span class="line">            casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">            <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">                traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spinning Ms: steal work from other Ps.</span></span><br><span class="line">    <span class="keyword">if</span> mp.spinning || <span class="number">2</span>*sched.nmspinning.Load() &lt; gomaxprocs-sched.npidle.Load() &#123;</span><br><span class="line">        <span class="keyword">if</span> !mp.spinning &#123;</span><br><span class="line">            mp.becomeSpinning()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        gp, inheritTime, tnow, w, newWork := stealWork(now)</span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// Successfully stole.</span></span><br><span class="line">            <span class="keyword">return</span> gp, inheritTime, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> newWork &#123;</span><br><span class="line">            <span class="comment">// There may be new timer or GC work; restart to</span></span><br><span class="line">            <span class="comment">// discover.</span></span><br><span class="line">            <span class="keyword">goto</span> top</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        now = tnow</span><br><span class="line">        <span class="keyword">if</span> w != <span class="number">0</span> &amp;&amp; (pollUntil == <span class="number">0</span> || w &lt; pollUntil) &#123;</span><br><span class="line">            <span class="comment">// Earlier timer to wait for.</span></span><br><span class="line">            pollUntil = w</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://mylofty.github.io">JimmyDing</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://mylofty.github.io/2023/03/05/fa56b9696089/">https://mylofty.github.io/2023/03/05/fa56b9696089/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://mylofty.github.io" target="_blank">爱开源GoGo</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Go/">Go</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/01/06/9ba4498d462a/" title="nodejs简单使用"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">nodejs简单使用</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/05/16afd7bb2116/" title="golang垃圾回收"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">golang垃圾回收</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/05/16afd7bb2116/" title="golang垃圾回收"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-05</div><div class="title">golang垃圾回收</div></div></a></div><div><a href="/2022/03/05/fdad014c27d6/" title="Go抢占式调度"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-05</div><div class="title">Go抢占式调度</div></div></a></div><div><a href="/2023/03/05/288be19ac2c4/" title="go协程调度"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-05</div><div class="title">go协程调度</div></div></a></div><div><a href="/2023/03/05/820734fbd49f/" title="go程序启动过程"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-05</div><div class="title">go程序启动过程</div></div></a></div><div><a href="/2023/03/05/d7edae0820f1/" title="go语言数据结构"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-05</div><div class="title">go语言数据结构</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/notebook.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">JimmyDing</div><div class="author-info__description">种一棵树，最好的时间是十年前，其次是现在</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/mylofty"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎前来爱开源GoGo</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">2.4 GMP源码剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-%E5%8D%8F%E7%A8%8BG%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">2.4.1 协程G结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-%E7%BA%BF%E7%A8%8BM%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">2.4.2 线程M结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-3-%E5%A4%84%E7%90%86%E5%99%A8P%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">2.4.3 处理器P结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-5-%E5%8D%8F%E7%A8%8BG%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-text">2.4.5 协程G的创建过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-6-%E5%8D%8F%E7%A8%8BG%E7%9A%84%E9%80%80%E5%87%BA%E8%BF%87%E7%A8%8B"><span class="toc-text">2.4.6 协程G的退出过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-7-%E5%8D%8F%E7%A8%8BG%E7%9A%84%E5%88%87%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="toc-text">2.4.7 协程G的切换过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-8-%E5%8D%8F%E7%A8%8BG%E7%9A%84%E6%A0%88%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-text">2.4.8 协程G的栈内存分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-9-%E5%A4%84%E7%90%86%E5%99%A8P%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-text">2.4.9 处理器P的创建过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-9-%E7%BA%BF%E7%A8%8BM%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-text">2.4.9 线程M的创建过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-10-%E7%BA%BF%E7%A8%8BM%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-text">2.4.10 线程M的启动过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E8%B0%83%E5%BA%A6%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">2.5 调度器源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-1-%E7%B3%BB%E7%BB%9F%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-text">2.5.1 系统全局变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-2-%E8%B0%83%E5%BA%A6%E5%99%A8schedt%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">2.5.2 调度器schedt结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-3-%E8%B0%83%E5%BA%A6%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">2.5.3 调度器初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-4-%E8%B0%83%E5%BA%A6%E5%99%A8%E5%90%AF%E5%8A%A8%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B"><span class="toc-text">2.5.4 调度器启动调度流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-5-%E8%B0%83%E5%BA%A6%E5%99%A8%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B"><span class="toc-text">2.5.5 调度器调度流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-6-%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="toc-text">2.5.6 协程调度策略</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/05/09/045d8c332459/" title="vllm使用教程-基于qwen模型"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="vllm使用教程-基于qwen模型"/></a><div class="content"><a class="title" href="/2025/05/09/045d8c332459/" title="vllm使用教程-基于qwen模型">vllm使用教程-基于qwen模型</a><time datetime="2025-05-09T06:51:21.000Z" title="发表于 2025-05-09 14:51:21">2025-05-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/14/36b4391cdd6f/" title="解锁AI潜能：万字详解大语言模型提示工程的终极指南"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="解锁AI潜能：万字详解大语言模型提示工程的终极指南"/></a><div class="content"><a class="title" href="/2024/08/14/36b4391cdd6f/" title="解锁AI潜能：万字详解大语言模型提示工程的终极指南">解锁AI潜能：万字详解大语言模型提示工程的终极指南</a><time datetime="2024-08-14T06:51:21.000Z" title="发表于 2024-08-14 14:51:21">2024-08-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/11/fa22652bbbc5/" title="RAG应用"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RAG应用"/></a><div class="content"><a class="title" href="/2024/06/11/fa22652bbbc5/" title="RAG应用">RAG应用</a><time datetime="2024-06-11T06:51:21.000Z" title="发表于 2024-06-11 14:51:21">2024-06-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/07/225dc84728ab/" title="大模型意图选择"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="大模型意图选择"/></a><div class="content"><a class="title" href="/2024/06/07/225dc84728ab/" title="大模型意图选择">大模型意图选择</a><time datetime="2024-06-07T06:51:21.000Z" title="发表于 2024-06-07 14:51:21">2024-06-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/11/3148f0b756e9/" title="pytorch导学：使用bert实现分类任务"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="pytorch导学：使用bert实现分类任务"/></a><div class="content"><a class="title" href="/2024/05/11/3148f0b756e9/" title="pytorch导学：使用bert实现分类任务">pytorch导学：使用bert实现分类任务</a><time datetime="2024-05-11T06:51:21.000Z" title="发表于 2024-05-11 14:51:21">2024-05-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/10/981ace98feb5/" title="pytorch基础：FashionMNIST时装分类"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="pytorch基础：FashionMNIST时装分类"/></a><div class="content"><a class="title" href="/2024/05/10/981ace98feb5/" title="pytorch基础：FashionMNIST时装分类">pytorch基础：FashionMNIST时装分类</a><time datetime="2024-05-10T06:51:21.000Z" title="发表于 2024-05-10 14:51:21">2024-05-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/26/111ea67534ab/" title="redis基础知识"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="redis基础知识"/></a><div class="content"><a class="title" href="/2024/04/26/111ea67534ab/" title="redis基础知识">redis基础知识</a><time datetime="2024-04-25T16:00:00.000Z" title="发表于 2024-04-26 00:00:00">2024-04-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/23/a07a83071c8a/" title="腹肌锻炼"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="腹肌锻炼"/></a><div class="content"><a class="title" href="/2024/04/23/a07a83071c8a/" title="腹肌锻炼">腹肌锻炼</a><time datetime="2024-04-23T06:51:21.000Z" title="发表于 2024-04-23 14:51:21">2024-04-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By JimmyDing</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>